# script-7

# author: Cheng Peng
# brief : this script implements all of the components (scipt1-6) to match flight frames(generated by script-0) with database, 
# and generates the best matches, as well as print out the time performance of each function/script.

# pre-require: a folder that contains all the flight frames & a folder that contains database grids (including grid.json file).

# -----------------------------------------------------------------------------
# import modules

import argparse
import os
import glob
import shutil
import json
import time
from itertools import cycle

def main():

    # ----- parse arguments -----

    parser = argparse.ArgumentParser(description='Animation of Navigation')
    parser.add_argument('flights_location', help="Requires a flight frames location")
    parser.add_argument('database_location', help="Requires a database grids location")
    parser.add_argument('frames_filetype', help="Requires the file type of flight frames")
    parser.add_argument('grids_filetype', help="Requires the file type of database grids")
    parser.add_argument('hessian_threshold', help="Requires a hessian threshold") # suggested value: 800
    parser.add_argument('ratio_position', default=2, nargs='?', help="requires the position of ratio value [0-6]") # 2(ratio = 0.60) by default
    parser.add_argument('top_candidates', default=8, nargs='?', help="requires the number of top matched grids") # 8 by default
    parser.add_argument('repeated_points', default=5, nargs='?', help="requires the number of repeated matches") # 5 by default
    parser.add_argument('cycle_scan', default=1, nargs='?', help="requires a cycle of scan") # 1=full scan by default, 2=full/partial, 3=full/2partial
    args = parser.parse_args()

    ft_location = args.flights_location
    db_location = args.database_location
    ft_type = args.frames_filetype
    db_type = args.grids_filetype
    hessian_threshold = args.hessian_threshold
    ratio_position = str(args.ratio_position)
    top_candidates = str(args.top_candidates)
    repeated_points = str(args.repeated_points)
    cycle_scan = int(args.cycle_scan)
    
    # ----- default name of directories -----

    keypoints_frame = "frame"
    keypoints_grids = "grid"
    gps_keypoints = "gps_keypoints"
    summary_frame_grids = "frame_grids"
    summary_of_matches = "output"
    
    # -----------------------------------------------------------------------------
    # datadase grids
    
    # ----- feature command -----
    
    start = time.time()
    
    # command that generates keypoint files of database grids
    current_directory = os.getcwd()
    cmd_db = "python " + os.path.join(os.environ['VISUAL_NAV_PROJECT'],"generate_all_image_keypoints.py")
    directory_keypoints_grids = os.path.join(current_directory, keypoints_grids)
    cmd_db += " " + db_location + " " + db_type + " " + directory_keypoints_grids + " " + hessian_threshold
    os.system(cmd_db)
    
    end_kp_grids  = time.time()
    
    # -----------------------------------------------------------------------------
    # GPS of grids keypoints
    
    # ----- feature command -----
    
    # command that generates gps of keypoints in keypoint files
    cmd_gps = "python " + os.path.join(os.environ['VISUAL_NAV_PROJECT'],"generate_keypoint_gps.py")
    cmd_gps += " " + directory_keypoints_grids + " "
    location_summary_grid = os.path.join(db_location, "grid.json")
    directory_gps_keypoints = os.path.join(current_directory, gps_keypoints)
    cmd_gps += location_summary_grid + " " + directory_gps_keypoints
    os.system(cmd_gps)
    
    end_gps = time.time()
    
    
    # -----------------------------------------------------------------------------
    # flight frames
    
    # ----- collect flight frames in date order -----
    
    list_flight_files = glob.glob(os.path.join(ft_location, '*.' + ft_type))
    list_flight_files.sort(key=os.path.getmtime)
    
    myiterator = cycle(range(cycle_scan)) # generator that allows to do a full scan or n partial scan
    
    t2_list = list()   # a list that contains time for generate keypoints of each frame
    t3_list = list()
    t4_list = list()
    
    for frame in list_flight_files:
        
        scan = next(myiterator)
        
        location_frame = os.path.join(current_directory, os.path.basename(frame).split('.')[0] + "_" + hessian_threshold)
        
        # ----- make a frame directory -----
        
        if not os.path.exists(location_frame):
            os.makedirs(location_frame)

        # ----- copy frame to location -----
        
        shutil.copy(frame, location_frame)

        frame_start = time.time()

        # ----- feature command -----

        # command that generates keypoint file of the flight frame
        cmd_fr = "python " + os.path.join(os.environ['VISUAL_NAV_PROJECT'],"generate_all_image_keypoints.py")
        output_location = os.path.join(location_frame, keypoints_frame)
        cmd_fr += " " + location_frame + " " + ft_type + " " + output_location + " " + hessian_threshold
        os.system(cmd_fr)
        
        end_kp_frame = time.time()
        
        # command that match the frame to grids keypoint files
        cmd_match = "python " + os.path.join(os.environ['VISUAL_NAV_PROJECT'],"match_flight_to_grid_keypoints.py")
        jsonfile = os.path.basename(frame.replace('.' + ft_type, '.json'))
        location_keypoints_frame = os.path.join(output_location, jsonfile)
        cmd_match += " " + location_keypoints_frame + " " + directory_keypoints_grids
        output_location = os.path.join(location_frame, summary_frame_grids)
        if scan == 0 or best_grid == 'None None':
            cmd_match += " " + output_location + " 0" # do a full scan, when a cycle is done or no best grid detected
        else:
            cmd_match += " " + output_location + " " + best_grid  # otherwise, do a partial scan
        os.system(cmd_match)

        end_match = time.time()

        # command that find the best matched grid and generates images
        cmd_img = "python " + os.path.join(os.environ['VISUAL_NAV_PROJECT'], "find_best_matches.py")
        location_match_summary = os.path.join(output_location, "summary.json")
        cmd_img += " " + location_match_summary + " " + directory_gps_keypoints + " " + frame + " " + db_location
        output_location = os.path.join(location_frame, summary_of_matches)
        cmd_img += " " + output_location
        cmd_img += " " + hessian_threshold + " " + ratio_position + " " + top_candidates + " " + repeated_points
        os.system(cmd_img)

        end_find = time.time()

        # reduce scan area by updating the best matched grid
        with open(os.path.join(output_location, "summary_matches.json"), "r") as fi:
            matches_dict = json.load(fi)
            for key, value in matches_dict.items():
                if key == '-1':
                    best_grid = str(value[0]) + " " + str(value[1])
        
        t2 = end_kp_frame - frame_start # time for generate keypoints of a frame
        t3 = end_match - end_kp_frame   # time for generate matches for a frame-grids matching
        t4 = end_find - end_match   # time for generate best match and ouput images for a frame
        t2_list.append(t2)
        t3_list.append(t3)
        t4_list.append(t4)

    end = time.time()
    time_sec = end - start

    t0 = end_kp_grids - start   ## running time for generate keypoints of grids
    t1 = end_gps - end_kp_grids  ## running time for generate gps of keypoints

    filename = "summary_time"
    file_o = "{0}.txt".format(filename)
    with open(file_o, "w") as fo:
        fo.write("Total running time:" + str(time_sec // 60) + "mins " + str(time_sec % 60) + "secs\n" + "Time of generating keypoints of grids:" + str(t0 // 60) + "mins " + str(t0 % 60) + "secs\n" + "Time of generating gps of keypoints:"+ str(t1 // 60) + "mins " + str(t1 % 60) + "secs\n")

        kp_frames = 0
        for time_kp_frame in t2_list:
            kp_frames += time_kp_frame
        fo.write("Time of generate keypoints for all frames:" + str(kp_frames // 60) + "mins " + str(kp_frames % 60) + "secs\n")
        match_frames = 0
        for time_match in t3_list:
            match_frames += time_match
        fo.write("Time of generate matches for all frames:" + str(match_frames // 60) + "mins " + str(match_frames % 60) + "secs\n")
        find_frames = 0
        for time_find in t4_list:
            find_frames += time_find
        fo.write("Time of generate best match and images for all frames:" + str(find_frames // 60) + "mins " + str(find_frames % 60) + "sec\n")

# -----------------------------------------------------------------------------
# run script

if __name__ == '__main__':
    main()
